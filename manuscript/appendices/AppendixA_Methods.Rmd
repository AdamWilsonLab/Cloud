Appendix B: Validation
=======================

This appendix includes details of the validation procedure.


```{r,setup,echo=F,results='hide',message=F}
## some setup

uploadimages=F  # upload all images to imgur.com for easy viewing on github
opts_knit$set(progress = TRUE, verbose = TRUE,root.dir="../../",cache=!uploadimages)
if(uploadimages) opts_knit$set(upload.fun =imgur_upload)
opts_chunk$set(fig.width=10, fig.height=8, cache=!uploadimages)
getwd()
## libraries
library(rasterVis)
library(latticeExtra)
library(xtable)
library(texreg)
library(reshape)
library(caTools)
library(rgeos)
library(raster)
library(plyr)
library(knitr)
require(knitcitations)
library(BayesFactor)

## read in global coasts for nice plotting
library(maptools)
library(rgdal)

```

```{r, loaddata,echo=FALSE,results='hide',message=F}

# read in data
cldm=read.csv("data/validation/cldm.csv",sep=",",row.names=NULL)
st=readOGR("data/validation","stations")
## month factors
cldm$month2=factor(cldm$month,labels=month.name,ordered=T)

### Drop valitation station-months with fewer than 20 years of data for full record or less than 10 years for MODIS-era record
cldm$cld_all[cldm$cldn_all<20]=NA
cldm$cldsd_all[cldm$cldn_all<20]=NA

cldm$cld[cldm$cldn<10]=NA
cldm$cldsd[cldm$cldn<10]=NA

cldm$seas=ifelse(cldm$month%in%c(12,1,2),"DJF",
                 ifelse(cldm$month%in%3:4,"MAM",
                        ifelse(cldm$month%in%5:8,"JJA",
                               ifelse(cldm$month%in%9:11,"SON",NA))))
cldm$seas=factor(cldm$seas,levels=c("DJF","MAM","JJA","SON"),ordered=T)

## compute seasonal means
cldml=melt(cldm,id.vars=c("StaID","lat","lon","lulcc","biome","seas"),measure.vars=c("cld_all","cldsd_all","cldn_all","cld","cldsd","cldn","mod09","mod09sd"))
clds=cast(cldml,StaID+lat+lon+lulcc+biome+seas~variable,value="value",fun=mean,na.rm=T)

## load land data for nice plotting
land=readShapePoly("data/gshhs/GSHHS_c_L1.shp",force_ring=TRUE)
projection(land)="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
CP <- as(extent(-180, 180, -60, 84), "SpatialPolygons")
proj4string(CP) <- CRS(proj4string(land))
coast=as(land[land$area>50,],"SpatialLines")
## Clip the map
land <- gIntersection(land, CP, byid=F)
coast <- gIntersection(coast, CP, byid=F)

## plotting parameters
n=100
at=seq(0,100,length=n)
colr=colorRampPalette(c("black","green","red"))
cols=colr(n)

## set plotting parameters
my.theme = trellis.par.get()
my.theme$strip.background=list(col="transparent")
trellis.par.set(my.theme)

greg=list(ylim=c(-60,84),xlim=c(-180,180))
    
bgr=function(x,n=100,br=0,c1=c("darkblue","blue","grey"),c2=c("grey","red","purple")){
    at=unique(c(seq(min(x,na.rm=T),max(x,na.rm=T),len=n)))
    bg=colorRampPalette(c1)
    gr=colorRampPalette(c2)
    return(list(at=at,col=c(bg(sum(at<br)),gr(sum(at>=br)))))
}

````

```{r,getvariables,echo=FALSE,message=F}
#########################################
### Some stats 
## number of stations retained
nstation_all=length(unique(cldm$StaID[!is.na(cldm$cld_all)]))
nstation_mod=length(unique(cldm$StaID[!is.na(cldm$cld)]))

# approximate size of M*D09GA archive - get total size for one day from the USGS website
size=as.numeric(
  sub("M","",
      grep("[0-9]*M$",
           scan("http://e4ftl01.cr.usgs.gov/MOLT/MOD09GA.005/2000.04.30/",what="char"),
           value=T)))
## extract all filesizes in MB (all the HDFs) and sum them and covert to TB for the length of the full record
tsize=sum(size)/1024/1024*as.numeric(as.Date("2014-03-31")-as.Date("2000-02-24"))*2

## Validation table construction
#quantile(cldm$difm,na.rm=T)
#summary(lm(cld_all~mod09+lat,data=cldm))
```

## Station Observations

The monthly CF were validated using a global observational dataset of synoptic weather reports collected at 5388 stations over 1971-2009 (Eastman and Warren 2012).  We extracted the mean “total cloud” amount for each month, which represents the mean proportion of the sky that was covered by all types of cloud during the observations in that month.  Comparison of these observations to satellite data must take into account that the sampling radius of these observations (the visible sky) depends on cloud height, cloud thickness, the curvature of the earth, and other factors, but is typically much larger than a single 1km MODIS pixel.  We followed Dybbroe, Karlsson, and Thoss (2005) and took the mean monthly MODCF for a circle with 16km radius around each station location.  Additionally, this converts the temporal MODCF to mean cloud amount within the sample radius to make it comparable to the station observations.



The monthly MODCF (including data from 2000-2013) were compared to station observations using linear models over the full station record (1970-2009) and the MODIS era (2000-2009) to assess accuracy and relevance of the 14-year satellite-derived data for estimating long-term monthly climatologies.  For the full record comparison, the station dataset was filtered to include only stations with at least 20 observations per month for at least 20 years, which retained `r nstation_all` stations.  Several countries (notably the USA, Canada, and New Zealand) converted from human cloud observations to automated laser ceilometers over the past decade leading to a decline in the number of observations over 1997-2009 (Eastman and Warren 2012). For the MODIS era comparison, we included only stations with at least 20 observations per month for the full 10-year period (2000-2009), so the number of stations available was reduced to `r nstation_mod`. 


### Monthly Comparison
```{r,monthscatter,results='hide',echo=FALSE,message=F}
hmcols=colorRampPalette(c("grey","blue","red","purple"))
#hmcols=colorRampPalette(c(grey(.8),grey(.3),grey(.2)))
tr=c(0,20)
colkey <- draw.colorkey(list(col = hmcols(tr[2]), at = tr[1]:tr[2],height=.25))

xyplot(cld~mod09|month2,data=cldm,panel=function(x,y,subscripts){
  n=50
  bins=seq(0,100,len=n)
  tb=melt(as.matrix(table(
    x=cut(x,bins,labels=bins[-1]),
    y=cut(y,bins,labels=bins[-1]))))
  qat=unique(tb$value)
  print(max(qat))
  qat=tr[1]:tr[2]#unique(tb$value)
  panel.levelplot(tb$x,tb$y,tb$value,at=qat,col.regions=c("transparent",hmcols(length(qat))),subscripts=1:nrow(tb))
#  panel.abline(0,1,col="black",lwd=2)
  panel.abline(lm(y ~ x),col="black",lwd=2)
#  panel.ablineq(lm(y ~ x), r.sq = TRUE,at = 0.6,pos=1, offset=0,digits=2,col="blue")
  panel.text(70,10,bquote(paste(R^2,"=",.(round(summary(lm(y ~ x))$r.squared,2)))),cex=1)
},asp=1,scales=list(at=seq(0,100,len=6),useRaster=T,colorkey=list(width=.5,title="Number of Stations")),
          ylab="NDP Mean Cloud Amount (%)",xlab="MODCF Cloud Frequency (%)",
              legend= list(right = list(fun = colkey)))+ layer(panel.abline(0,1,col="grey",lwd=2),under=T)
```
Mean monthly cloud amount over 1970-2009 from 5388 global stations versus mean 2000-2009 MOD09 cloud frequency by month.  Coefficient of determination is shown in each panel.  Colors represent the number of monthly station observations within each grid cell of the scatterplot.


#### Spatial Distribution 
```{r,mapresidmonth,echo=FALSE,message=F}
cldm$resid=NA
# get residuals of simple linear model
cldm$resid[!is.na(cldm$cld_all)&!is.na(cldm$mod09)]=residuals(lm(mod09~cld_all,data=cldm[!is.na(cldm$cld_all)&!is.na(cldm$mod09),]))
colat=bgr(cldm$resid)
phist=histogram(cldm$resid,breaks=colat$at,border=NA,col=colat$col,xlim=c(-30,30),type="count",xlab="MODCF Residuals")#,seq(0,1,len=6),na.rm=T)
pmap=xyplot(lat~lon|month2,data=cldm,groups=cut(cldm$resid,rev(colat$at)),
       par.settings=list(superpose.symbol=list(col=colat$col)),pch=16,cex=.25,
       auto.key=F,#list(space="right",title="Difference\n(MOD09-NDP026D)",cex.title=1),asp=1,
       ylab="Latitude",xlab="Longitude")+
  layer(sp.lines(coast,col="black",lwd=.1),under=F)
print(phist,position=c(0,.75,1,1),more=T)
print(pmap,position=c(0,0,1,.78))
```

Histogram and spatial distribution of residuals from linear model between station and satellite cloud amount at station locations.  Negative (positive) values indicate locations where MODCF was less than (greater than) expected given the global relationship between MODCF and station observations.  


### Seasonal Validation
In addition to monthly validation we also performed the same validation on the seasonal (DFJ,MAM,JJA,SON) mean values.
```{r,seasscatter,echo=FALSE,message=F,results='hide'}
tr2=c(0,37)
xyplot(cld_all~mod09|seas,data=clds,panel=function(x,y,subscripts){
  n=75
  bins=seq(0,100,len=n)
  tb=melt(as.matrix(table(
    x=cut(x,bins,labels=bins[-1]),
    y=cut(y,bins,labels=bins[-1]))))
  qat=unique(tb$value)
  print(max(qat))
  qat=tr2[1]:tr2[2]#unique(tb$value)
  panel.levelplot(tb$x,tb$y,tb$value,at=qat,col.regions=c("transparent",hmcols(length(qat))),subscripts=1:nrow(tb))
#  panel.abline(0,1,col="black",lwd=2)
  panel.abline(lm(y ~ x),col="black",lwd=2)
#  panel.ablineq(lm(y ~ x), r.sq = TRUE,at = 0.6,pos=1, offset=0,digits=2,col="blue")
  panel.text(70,10,bquote(paste(R^2,"=",.(round(summary(lm(y ~ x))$r.squared,2)))),cex=1)
},asp=1,scales=list(at=seq(0,100,len=6),useRaster=T,colorkey=list(width=.5,title="Number of Stations")),
          ylab="NDP Mean Cloud Amount (%)",xlab="MODCF Cloud Frequency (%)",
              legend= list(right = list(fun = colkey)))+ layer(panel.abline(0,1,col="grey",lwd=2),under=T)
```

```{r,seasmapresid,echo=FALSE,message=F}
clds$resid=NA
# get residuals of simple linear model
clds$resid[!is.na(clds$cld_all)&!is.na(clds$mod09)]=residuals(lm(mod09~cld_all,data=clds[!is.na(clds$cld_all)&!is.na(clds$mod09),]))
colat=bgr(clds$resid)
phist=histogram(clds$resid,breaks=colat$at,border=NA,col=colat$col,xlim=c(-30,30),type="count",xlab="MODCF Residuals")#,seq(0,1,len=6),na.rm=T)
pmap=xyplot(lat~lon|seas,data=clds,groups=cut(clds$resid,rev(colat$at)),
       par.settings=list(superpose.symbol=list(col=colat$col)),pch=16,cex=.25,
       auto.key=F,#list(space="right",title="Difference\n(MOD09-NDP026D)",cex.title=1),asp=1,
       ylab="Latitude",xlab="Longitude")+
  layer(sp.lines(coast,col="black",lwd=.1),under=F)
print(phist,position=c(0,.75,1,1),more=T)
print(pmap,position=c(0,0,1,.78))
```

___________________________
## Temporal Stability

```{r,tempsubset,echo=F,results='hide',message=F}
## spatialy subset data to stations at least 10km apart
st2=remove.duplicates(st,zero=10)

## Subset data
## drop missing observations
cldm.t=cldm[!is.na(cldm$cld_all)&!is.na(cldm$mod09)&!is.na(cldm$biome),]
cldm.t=cldm.t[cldm.t$lat>=-60,]
#  make sure all stations have all mod09 data
stdrop=names(which(tapply(cldm.t$month,cldm.t$StaID,length)!=12))
cldm.t=cldm.t[!cldm.t$StaID%in%stdrop,]
# Keep only stations at least 10km apart 
cldm.t=cldm.t[cldm.t$StaID%in%st2$id,]
## Subset to only some months, if desired
#cldm.t=cldm.t[cldm.t$month%in%1:3,]

### Compare time periods
library(texreg)
 extract.lm <- function(model) {
     s <- summary(model)
     names <- rownames(s$coef)
     co <- s$coef[, 1]
     se <- s$coef[, 2]
     pval <- s$coef[, 4]
     rs <- s$r.squared
     n <- as.integer(nobs(model))
     rmse=sqrt(mean((residuals(s)^2)))
     gof <- c(rs, rmse, n)
     gof.names <- c("R-Squared","RMSE","n")
     tr <- createTexreg(coef.names = names, coef = co, se = se, 
                        pvalues = pval, gof.names = gof.names, gof = gof)
     return(tr)
 }
setMethod("extract", signature = className("lm", "stats"),definition = extract.lm)
```

To assess the accuracy of the MODCF product in estimating multi-decadal cloud frequencies, we used linear models between the 2000-2014 satellite climatologies and station observations divided into two periods including the full station record (1970-2009) and the MODIS-era subset (2000-2009).     
```{r,modcomparetable,echo=F,results='asis',message=F}
forms=c("cld~mod09+month2+lat")
lm_all=lm(cld_all~mod09+lat,data=cldm[!is.na(cldm$cld),])


### Compare two time periods
lm_all1=lm(cld_all~mod09,data=cldm[!is.na(cldm$cld)&cldm$cldn_all>=10,])

lm_mod=lm(cld~mod09,data=cldm[cldm$cldn==10,])
mods=list("1970-2009"=lm_all1,"2000-2009"=lm_mod)

#screenreg(mods,digits=2,single.row=T,custom.model.names=names(mods),custom.coef.names = c("Intercept", "MODCF"))

htmlreg(mods,custom.model.names = names(mods),custom.coef.names = c("Intercept", "MODCF"),
        single.row = T, inline.css = T,doctype = F, html.tag = F, head.tag = F, body.tag = F,
        caption="Comparison of MODCF accuracy over two time periods, the full station record (1970-2009) and the 'MODIS-era' (2000-2014).")
```

____________________________
## Latitudinal Bias in MODCF

```{r,latbiasboxplot,echo=F,results='asis',message=F}
## add latitudinal bins to cldm
cldm$latbin=cut(cldm$lat,seq(-90,90,by=20),include.lowest=T)

bwcols=list(col=grey(0.4),pch=16,cex=.5)
bwplot(latbin~resid|seas,type=c("p","smooth"),data=cldm,cex=.25,pch=16,xlab="Validation Error (MODCF-Station)",ylab="20-Degree Latitude Bin",fill="grey",layout=c(4,1),scales=list(x=list(rot=45)),
       par.settings = list(plot.symbol=bwcols,box.dot =bwcols),notch=T,varwidth=T)+
  layer(panel.abline(h=5,col="grey"),under=T)+
  layer(panel.abline(v=0,col="red"),under=T)

#bf=anovaBF(resid~lulcc+month2,data=cldm[!is.na(cldm$resid)&!is.na(cldm$lulcc),])
#ch=posterior(bf, iterations = 1000)
#summary(bf)
#plot(bf)
```

The MODCF tends to overestimate CF at higher latitudes in winter months, and underestimate it in summer months.  

```{r,latbias,echo=F,results='asis',message=F}
sumfun=function(x){
    n <- length(na.omit(x))
    rmse=sqrt(mean((x^2),na.rm=T))
    if(is.nan(rmse))return("")
    paste(round(rmse,1)," (",n,")",sep="")
     }
lb=cast(cldm,seas~latbin,value="resid",fun=sumfun)

print(xtable(lb),type="html")

```

____________________________
## Assess Land-Use Land-Cover bias
```{r,lulcbias,echo=FALSE,message=F,results='hide'}
bwplot(lulcc~resid,data=cldm,horiz=T,xlab="Residuals (MOD09-Observed)",varwidth=T,notch=T)+layer(panel.abline(v=0))
```

Boxplot showing residuals (MOD09-Station) by land cover type.  

```{r,lulctable,echo=F,message=F,results='asis'}
## Table of RMSE's by lulc by month

lulct=cast(cldm,lulcc~seas,value="resid",fun=sumfun)

print(xtable(lulct,caption="Table of RMSE's (count) by season (column) and Land Cover (row)"),type="html",include.rownames=F,row.names=F)
```


```{r,lulclevelplot,echo=FALSE,message=F,results='hide'}
lulctl=ddply(cldm,c("seas","lulcc"),function(x) c(count=nrow(x),rmse=sqrt(mean(x$resid^2,na.rm=T))))
lulctl=lulctl[!is.na(lulctl$lulcc),]

bgyr=colorRampPalette(c("blue","green","yellow","red"))
levelplot(rmse~seas*lulcc,data=lulctl,col.regions=bgyr(1000),at=quantile(lulctl$rmse,seq(0,1,len=100),na.rm=T),xlab="Season",ylab="Land Cover")

```


